<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title> Content Uniformity Tests Implementation Based on Monte-Carlo simulation in C++ and Python  | 环形缓冲</title>
<meta name="description" content="HXHC Blog" />
<link rel="shortcut icon" href="https://hxhc.xyz/favicon.ico?v=1715403560277">
<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.0/animate.min.css" integrity="sha256-HtCCUh9Hkh//8U1OwcbD8epVEUdBvuI8wj1KtqMhNkI=" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/mermaid@8.11.0/dist/mermaid.min.js" integrity="sha256-sVAx+v/Q7v0Q2xm5vN7h5ccSna6gaLREhG9sF8pKT6I=" crossorigin="anonymous"></script> -->

<!-- <link href="
https://cdn.jsdelivr.net/npm/@openfonts/noto-serif-sc_chinese-simplified@1.44.2/index.min.css
" rel="stylesheet"> -->
<link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/KaTeX/0.11.1/katex.min.css">
<link href="https://cdn.bootcdn.net/ajax/libs/remixicon/4.2.0/remixicon.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/animate.css/4.1.1/animate.min.css">
<script src="https://cdn.bootcdn.net/ajax/libs/mermaid/9.1.1/mermaid.min.js"></script>


<link rel="stylesheet" href="https://hxhc.xyz/styles/main.css">





  </head>

  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="ri-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://hxhc.xyz">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://hxhc.xyz/images/avatar.png?v=1715403560277" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">环形缓冲</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            Table of Contents
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#the-python-version">The Python version</a>
<ul>
<li><a href="#cutest-class">CUtest class</a></li>
<li><a href="#cusim-methods">CUsim methods</a></li>
</ul>
</li>
<li><a href="#c-version">C++ version</a>
<ul>
<li><a href="#cutest-class-2">CUtest class</a></li>
<li><a href="#cusim-methods-2">CUsim methods</a></li>
<li><a href="#binding">Binding</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="ri-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          Home
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          Archives
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          Tags
        </a>
      
    
      
        <a href="https://notes.hxhc.xyz" class="menu" style="animation-delay: 0.6000000000000001s" target="_blank">
          Notes
        </a>
      
    
      
        <a href="https://photos.hxhc.xyz" class="menu" style="animation-delay: 0.8s" target="_blank">
          Photo
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 1s">
          About
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700">Great ideas in mind<br>
Poor words on paper</div>
    <a class="rss" href="https://hxhc.xyz/atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()" style="backdrop-filter: blur(7px); background: hsla(0, 0%, 100%, 0.5); -webkit-backdrop-filter: blur(7px);">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16"> Content Uniformity Tests Implementation Based on Monte-Carlo simulation in C++ and Python </h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2022-05-16 / 35 min read
        </div>
        
          <img class="post-feature-image rounded-lg mx-auto my-4" src="https://hxhc-blog.oss-cn-hangzhou.aliyuncs.com/img/picgoR-C.jpg" alt="">
        
        <div class="post-content yue">
          <p>Content uniformity tests process Implemention in C++ and Python codes. Using C++ to speed codes for 100 times.</p>
<!-- more -->
<p>Content uniformity (CU) is crucial for drug products. In the Chinese Pharmacopoeia(ChP) and the United States Pharmacopedia (USP), CU tests are similar but still have some differences. To find out the how the CU tests in ChP and USP (denoted as ChPCU and USPCU) differ under different circumstances, we implemented a simulation study based on Monte-Carlo.  The results of the study can be found in the <a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFDLAST2019&amp;filename=XDYD201919008&amp;uniplatform=NZKPT&amp;v=af_cKxWVK9Tz0-xpi45aIx6skFLa8Jq8fBKS_5Dw1V4q7cXQi5pupKwRa_QXsFt2">paper</a><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>.</p>
<p>In this blog, I released the code of the Monte Carlo simulation process in both Python and C++. Just for myself to remember the code details.</p>
<h2 id="the-python-version">The Python version</h2>
<h3 id="cutest-class">CUtest class</h3>
<p>The core of the simulation experiement is the CU test. We used Monte-Carlo method to call the CU test repeatedly and then got the accuracy and other metrics of ChPCU and USPCU. Therefore, the CU test is wrapped into a class firstly.</p>
<pre><code class="language-python"># CUtest.py

# -*- coding: utf-8 -*-
import numpy as np


class ChPtest():
    &quot;&quot;&quot;ChPtest provides Content Uniformity test in Chinese Pharmacopeia

    &quot;&quot;&quot;

    def __init__(self, s1, s2, k1=2.2, k2=0.25, k3=1.7, L=15):
        &quot;&quot;&quot;input two (numpy) arrays, s1 and s2, as the sampling results
        in the fist stage and the second stage.

        Parameters
        ----------
        s1 : array like
            the sampling result in the first stage of content uniformity test
            size should be equal to 10.
        s2 : array like
            the sampling result in the second stage of content uniformity test
            size should be equal to 20.
        k1 : float
            parameter in ChP 0941
        k2: float
            parameter in ChP 0941
        k3: float
            parameter in ChP 0941
        L: float
            parameter in ChP 0941
        &quot;&quot;&quot;

        if len(s1) != 10:
            raise ValueError('THe length of s1 should be 10')
        elif len(s2) != 20:
            raise ValueError('The length of s2 should be 20')
        else:
            self.stage1 = s1
            self.__s2 = s2
            self.k1 = k1
            self.k2 = k2
            self.k3 = k3
            self.L = L
            self.stage2 = np.concatenate([s1, s2])    # merge s1 and s2 into stage2
            self.mean_s1 = np.mean(self.stage1)
            # sd: degree of freedom = n-1, in accordance with ChP 0941
            self.sd_s1 = np.std(self.stage1, ddof=1)    # unbiased estimator
            self.mean_s2 = np.mean(self.stage2)
            self.sd_s2 = np.std(self.stage2, ddof=1)

    def result(self):
        &quot;&quot;&quot;returns ChPtest result

        Returns
        -----------
        [pass_s1, pass_s2, fail_s1, fail_s2]: numpy arrays
            pass_s1: 0 or 1. If passes in stage 1 test, the value is 1.
            pass_s2: 0 or 1. If passes in stage 2 test, the value is 1.
            fail_s1: 0 or 1. If fails in stage 1 test, the value is 1.
            fail_s2: 0 or 1. If fails in stage 2 test, the value is 1.

        &quot;&quot;&quot;
        # initialization with 0
        pass_s1 = 0
        fail_s1 = 0
        pass_s2 = 0
        fail_s2 = 0

        # if passes stage 1 test, pass_1 add 1
        # if fails stage 1 test, fail_1 add 1
        # if keeps unclear, go to stage 2 test
        Ave = abs(100 - self.mean_s1)
        if Ave + self.k1 * self.sd_s1 &lt;= self.L:    # if A + k1 * sd &lt; L, pass
            pass_s1 = 1
        elif Ave + self.sd_s1 &gt; self.L:    # if A + sd &gt; L, fail
            fail_s1 = 1

        # stage 2 test
        else:
            Ave = abs(100 - self.mean_s2)    # recalculate Ave
            if Ave &lt;= self.k2 * self.L:    # if A &lt;= k2 * L
                # if A^2 + sd^2 &lt;= k2 * L, pass
                if Ave ** 2 + self.sd_s2 ** 2 &lt;= self.k2 * self.L ** 2:
                    pass_s2 = 1
                else:
                    fail_s2 = 1
            else:
                # if A &gt; k2 * L and A + k3 * sd &lt;= L, pass
                if Ave + self.k3 * self.sd_s2 &lt;= self.L:
                    pass_s2 = 1
                else:
                    fail_s2 = 1
        return np.array([pass_s1, pass_s2, fail_s1, fail_s2])


class USPtest():
    &quot;&quot;&quot;USPtest provides Content Uniformity test in US Pharmacopeia.

    &quot;&quot;&quot;
    def __init__(self, s1, s2, k1=2.4, k2=2.0, L1=15, L2=25):
        if len(s1) != 10:
            raise ValueError('THe length of s1 should be 10')
        elif len(s2) != 20:
            raise ValueError('The length of s2 should be 20')
        else:
            self.stage1 = s1
            self.__s2 = s2
            self.stage2 = np.concatenate([s1, s2])    # merge s1 and s2 into stage2
            self.k1 = k1
            self.k2 = k2
            self.L1 = L1
            self.L2 = L2
            self.mean_s1 = np.mean(self.stage1)
            # sd: degree of freedom = n-1, in accordance with USP 905
            self.sd_s1 = np.std(self.stage1, ddof=1)    # unbiased estimator
            self.mean_s2 = np.mean(self.stage2)
            self.sd_s2 = np.std(self.stage2, ddof=1)

    def result(self):
        &quot;&quot;&quot;returns the USPtest result

        Returns
        -----------
        [pass_s1, pass_s2, fail_s1, fail_s2]: numpy arrays
            pass_s1: 0 or 1. If passes in stage 1 test, the value is 1.
            pass_s2: 0 or 1. If passes in stage 2 test, the value is 1.
            fail_s1: 0 or 1. If fails in stage 1 test, the value is 1.
        Indeed, the value of fail_s1 should always be 0 because USP 905 goes to
        the stage 2 test directly instead of giving a result of fail
        if it fails in the stage 1 test.

            fail_s2: 0 or 1. If fails in stage 2 test, the value is 1.

        &quot;&quot;&quot;
        pass_s1 = 0
        fail_s1 = 0    # no fail in stage 1 test indeed
        pass_s2 = 0
        fail_s2 = 0

        # if passes stage 1 test, pass_s1 add 1
        # if fails stage 1 test, go to stage 2 test
        if self.mean_s1 &lt; 98.5:
            Ave = 98.5 - self.mean_s1
        elif self.mean_s1 &gt; 101.5:
            Ave = self.mean_s1 - 101.5
        else:
            Ave = 0

        # stage 1 test
        if Ave + self.k1 * self.sd_s1 &lt;= self.L1:    # if A + k1 * sd &lt;= L1
            pass_s1 = 1

        # stage 2 test
        else:
            if self.mean_s2 &lt; 98.5:
                Ave2 = 98.5 - self.mean_s2
                limit = 98.5
            elif self.mean_s2 &gt; 101.5:
                Ave2 = self.mean_s2 - 101.5
                limit = 101.5
            else:
                Ave2 = 0
                limit = self.mean_s2

            # Ave + k2 * sd &lt;= L1 and all the tablets fall in the quality range
            if ((Ave2 + self.k2 * self.sd_s2 &lt;= self.L1) &amp;
               (np.all(self.stage2 &gt;= (1 - 0.01 * self.L2) * limit)) &amp;
               (np.all(self.stage2 &lt;= (1 + 0.01 * self.L2) * limit))):
                pass_s2 = 1
            else:
                fail_s2 = 1

        return np.array([pass_s1, pass_s2, fail_s1, fail_s2])
</code></pre>
<h3 id="cusim-methods">CUsim methods</h3>
<p>The Monte-Carlo experiments are implemented in the <code>CUsim.py</code>. Two methods are provided, <code>sim_sd</code> and <code>sim_mu</code>.</p>
<pre><code class="language-python"># CUsim.py

import numpy as np
from CUtest import ChPtest, USPtest


def sim_sd(mu, start, end, sd_num, sim_num=1000, n1=10, n2=20,
           low_lvl=85, upp_lvl=115, ck1=2.2, ck2=0.25, ck3=1.7, cL=15,
           uk1=2.4, uk2=2.0, uL1=15, uL2=25):
    &quot;&quot;&quot;sim_sd provides a method to simulate CUtest with nomal distributions
    which are under a given mean value and different standard deviations(`sd`).
    `sd` starting from `start` and ending with `end`, are evenly spaced.

    Parameters
    ----------
    mu : float
        The mean value of the normal distribution.
    start : float
        The starting standard deviation of the normal distribution.
    end : float
        The ending standard deviation of the normal distribution.
    sd_num : int
        Number of sd to generate.
    sim_num : int, optional
        Number of test simulations to generate. Default is 1000.
    n1 : int, optional
        Number of samples tested in the stage 1.
        Default is 10, which complies with USP 905 and ChP 0941.
    n2 : int, optional
        Number of samples tested in the stage 2.
        Default is 20, which complies with USP 905 and ChP 0941.
    low_lvl : int, optional
        The lower content bound of qualified tablets.
        Default is 85, which means the content should not be less than 85%
        of the label claim.
    upp_lvl : int, optional
        The upper content bound of qualified tablets.
        Default is 115, which means the content should not be greater than 115%
        of the label claim.
    ck1 : float, optional
        The parameter in CUtest.ChPtest(), default is 2.2.
    ck2 : float, optional
        The parameter in CUtest.ChPtest(), default is 0.25.
    ck3 : float, optional
        The parameter in CUtest.ChPtest(), default is 1.7.
    cL : float, optional
        The paramter in CUtest.ChPtest(), default is 15.
    uk1 : float, optional
        The parameter in CUtest.USPtest(), default is 2.4.
    uk2 : float, optional
        The parameter in CUtest.USPtest(), default is 2.0.
    uL1 : float, optional
        The parameter in CUtest.USPtest(), default is 15.
    uL2 : float, optional
        The parameter in CUtest.USPtest(), default is 25.

    Returns
    -------
    Returns a list, containing `failrate`, `chp_acc_s1`, `chp_acc`, `usp_acc_s1`
    and `usp_acc`

    failrate: numpy array
        The rate of unqualified tablets in each simulated batch.
        The length eqauls to `sd_num`.
    chp_acc_s1: numpy array
        The stage 1 test accuracy of ChP 0941
    chp_acc: numpy array
        The test accuracy of ChP 0941.
    usp_acc_s1: numpy array
        The stage 1 test accuracy of USP 905.
    usp_acc: numpy array
        The test accuracy of USP 905.

    Note
    ---------
    In this function, accuray = (TP + TN) / (TP + FP + TN + FN)
    &quot;&quot;&quot;

    n_batch = 20000    # simulate 20k tablets in one batch
    # initialization with zeros
    failrate = np.zeros(sd_num)
    chp_fail_s1 = np.zeros(sd_num)
    chp_pass_s1 = np.zeros(sd_num)
    chp_fail_s2 = np.zeros(sd_num)
    chp_pass_s2 = np.zeros(sd_num)
    usp_fail_s1 = np.zeros(sd_num)    # no fail in stage 1 in USP indeed
    usp_pass_s1 = np.zeros(sd_num)
    usp_fail_s2 = np.zeros(sd_num)
    usp_pass_s2 = np.zeros(sd_num)
    chp_acc_s1 = np.zeros(sd_num)
    chp_acc = np.zeros(sd_num)
    usp_acc_s1 = np.zeros(sd_num)
    usp_acc = np.zeros(sd_num)

    for i in range(sd_num):
        # calc the sd in each loop
        sd = (end - start) / (sd_num - 1) * i + start
        # normal simulation
        X = np.random.normal(loc=mu, scale=sd, size=n_batch)
        failrate[i] = np.size(X[(X &gt; upp_lvl) | (X &lt; low_lvl)]) / n_batch

        # initialization with zeros
        # result =  np.array([pass_s1, pass_s2, fail_s1, fail_s2])
        chp_result = np.array([0, 0, 0, 0])
        usp_result = np.array([0, 0, 0, 0])

        for j in range(sim_num):
            # a faster version but the result accuracy may be slightly lower
            # rng_idx = np.random.randint(0, 19999, size=30)
            # s1 = X[rng_idx[:10]]
            # s2 = X[rng_idx[10:]]

            # a slower version but the result is definitely true
            Xperm = np.random.permutation(X)  # fisrt randomization
            s1 = Xperm[:n1]     # stage 1 sampling
            Xperm2 = np.random.permutation(X[n1:])    # second randomization
            s2 = Xperm2[:n2]    # stage 2 sampling

            chp = ChPtest(s1=s1, s2=s2, k1=ck1, k2=ck2, k3=ck3, L=cL)
            usp = USPtest(s1=s1, s2=s2, k1=uk1, k2=uk2, L1=uL1, L2=uL2)
            chp_result = chp_result + chp.result()
            usp_result = usp_result + usp.result()

        chp_pass_s1[i] = chp_result[0] / sim_num
        chp_pass_s2[i] = chp_result[1] / sim_num
        chp_fail_s1[i] = chp_result[2] / sim_num
        chp_fail_s2[i] = chp_result[3] / sim_num
        usp_pass_s1[i] = usp_result[0] / sim_num
        usp_pass_s2[i] = usp_result[1] / sim_num
        usp_fail_s1[i] = usp_result[2] / sim_num
        usp_fail_s2[i] = usp_result[3] / sim_num

        if failrate[i] &lt;= 0.05:
            chp_acc_s1[i] = chp_pass_s1[i]
            chp_acc[i] = chp_pass_s1[i] + chp_pass_s2[i]
            usp_acc_s1[i] = usp_pass_s1[i]
            usp_acc[i] = usp_pass_s1[i] + usp_pass_s2[i]
        else:
            chp_acc_s1[i] = chp_fail_s1[i]
            chp_acc[i] = chp_fail_s1[i] + chp_fail_s2[i]
            # usp_acc_s1[i] = usp_fail_s1[i]
            usp_acc[i] = usp_fail_s2[i]

    return [failrate, chp_acc_s1, chp_acc, usp_acc_s1, usp_acc]


def sim_mu(sd, start, end, mu_num, sim_num=1000, n1=10, n2=20,
           low_lvl=85, upp_lvl=115, ck1=2.2, ck2=0.25, ck3=1.7, cL=15,
           uk1=2.4, uk2=2.0, uL1=15, uL2=25):
    &quot;&quot;&quot;sim_mu provides a method to simulate CUtest with nomal distributions
    which are under a given standard deviation and different mean values(`mu`).
    `mu` starting from `start` and ending with `end`, are evenly spaced.

    Parameters
    ----------
    sd : float
        The standard deivation of the normal distribution.
    start : float
        The starting standard mean value of the normal distribution.
    end : float
        The ending mean value of the normal distribution.
    mu_num : int
        Number of `mu` to generate.
    sim_num : int, optional
        Number of test simulations to generate. Default is 1000.
    n1 : int, optional
        Number of samples tested in the stage 1.
        Default is 10, which complies with USP 905 and ChP 0941.
    n2 : int, optional
        Number of samples tested in the stage 2.
        Default is 20, which complies with USP 905 and ChP 0941.
    low_lvl : int, optional
        The lower content bound of qualified tablets.
        Default is 85, which means the content should not be less than 85%
        of the label claim.
    upp_lvl : int, optional
        The upper content bound of qualified tablets.
        Default is 115, which means the content should not be greater than 115%
        of the label claim.
    ck1 : float, optional
        The parameter in CUtest.ChPtest(), default is 2.2.
    ck2 : float, optional
        The parameter in CUtest.ChPtest(), default is 0.25.
    ck3 : float, optional
        The parameter in CUtest.ChPtest(), default is 1.7.
    cL : float, optional
        The paramter in CUtest.ChPtest(), default is 15.
    uk1 : float, optional
        The parameter in CUtest.USPtest(), default is 2.4.
    uk2 : float, optional
        The parameter in CUtest.USPtest(), default is 2.0.
    uL1 : float, optional
        The parameter in CUtest.USPtest(), default is 15.
    uL2 : float, optional
        The parameter in CUtest.USPtest(), default is 25.

    Returns
    -------
    Returns a list, containing `failrate`, `chp_acc_s1`, `chp_acc`, `usp_acc_s1`
    and `usp_acc`

    failrate: numpy array
        The rate of unqualified tablets in each simulated batch.
        The length eqauls to `mu_num`.
    chp_acc_s1: numpy array
        The stage 1 test accuracy of ChP 0941
        The length eqauls to `mu_num`.
    chp_acc: numpy array
        The test accuracy of ChP 0941.
        The length eqauls to `mu_num`.
    usp_acc_s1: numpy array
        The stage 1 test accuracy of USP 905.
        The length eqauls to `mu_num`.
    usp_acc: numpy array
        The test accuracy of USP 905.


    Note
    ---------
    In this function, accuray = (TP + TN) / (TP + FP + TN + FN)
    &quot;&quot;&quot;

    n_batch = 20000    # simulate 20k tablets in one batch
    # initialization with zeros
    failrate = np.zeros(mu_num)
    chp_fail_s1 = np.zeros(mu_num)
    chp_pass_s1 = np.zeros(mu_num)
    chp_fail_s2 = np.zeros(mu_num)
    chp_pass_s2 = np.zeros(mu_num)
    usp_fail_s1 = np.zeros(mu_num)    # no fail in stage 1 in USP indded
    usp_pass_s1 = np.zeros(mu_num)
    usp_fail_s2 = np.zeros(mu_num)
    usp_pass_s2 = np.zeros(mu_num)
    chp_acc_s1 = np.zeros(mu_num)
    chp_acc = np.zeros(mu_num)
    usp_acc_s1 = np.zeros(mu_num)
    usp_acc = np.zeros(mu_num)

    for i in range(mu_num):
        # calc the sd in each loop
        mu = (end - start) / (mu_num - 1) * i + start
        # normal simulation
        X = np.random.normal(loc=mu, scale=sd, size=n_batch)
        failrate[i] = np.size(X[(X &gt; upp_lvl) | (X &lt; low_lvl)]) / n_batch

        # initialization with zeros
        # result =  np.array([pass_s1, pass_s2, fail_s1, fail_s2])
        chp_result = np.array([0, 0, 0, 0])
        usp_result = np.array([0, 0, 0, 0])

        for j in range(sim_num):
            Xperm = np.random.permutation(X)  # fisrt randomization
            s1 = Xperm[:n1]     # stage 1 sampling
            Xperm2 = np.random.permutation(X[n1:])    # second randomization
            s2 = Xperm2[:n2]    # stage 2 sampling

            chp = ChPtest(s1=s1, s2=s2, k1=ck1, k2=ck2, k3=ck3, L=cL)
            usp = USPtest(s1=s1, s2=s2, k1=uk1, k2=uk2, L1=uL1, L2=uL2)
            chp_result = chp_result + chp.result()
            usp_result = usp_result + usp.result()

        chp_pass_s1[i] = chp_result[0] / sim_num
        chp_pass_s2[i] = chp_result[1] / sim_num
        chp_fail_s1[i] = chp_result[2] / sim_num
        chp_fail_s2[i] = chp_result[3] / sim_num
        usp_pass_s1[i] = usp_result[0] / sim_num
        usp_pass_s2[i] = usp_result[1] / sim_num
        usp_fail_s1[i] = usp_result[2] / sim_num
        usp_fail_s2[i] = usp_result[3] / sim_num

        if failrate[i] &lt;= 0.05:
            chp_acc_s1[i] = chp_pass_s1[i]
            chp_acc[i] = chp_pass_s1[i] + chp_pass_s2[i]
            usp_acc_s1[i] = usp_pass_s1[i]
            usp_acc[i] = usp_pass_s1[i] + usp_pass_s2[i]
        else:
            chp_acc_s1[i] = chp_fail_s1[i]
            chp_acc[i] = chp_fail_s1[i] + chp_fail_s2[i]
            # usp_acc_s1[i] = usp_fail_s1[i]
            usp_acc[i] = usp_fail_s2[i]

    return [failrate, chp_acc_s1, chp_acc, usp_acc_s1, usp_acc]
</code></pre>
<p>Mind that the 20k samples are generated using normal distributions, and 10/30 samples are drawn from the 20k samples. There are 2 ways to implement the <mark>sampling</mark> procedure. The one (used in this article) is to shuffle all the 20k samples randomly, and then drawing the first 10/30 samples. The other (shown in the <code>sim_sd</code> function) is randomly generating 10/30 integers smaller than 20k as the indices, and drawing the samples using the indices. The latter method is much faster, but chances are that one sample might be drawn 2 or more times, which is against the real procedure. However, given the population size is 20k, such situation hardly happens.</p>
<h2 id="c-version">C++ version</h2>
<p>The Python version costs a lot of time. The slowest part is to  shuffle the 20k samples. But if we choose the latter way to draw samples, the time is not totally satisfactory indeed. Because the code is doing a lot of loops, we may use <em>Numba</em> or <em>Cython</em> to speed the code. Another way or ultimate way is using C++ to cover the core code.</p>
<p>In this post, <a href="https://eigen.tuxfamily.org/index.php"><em>Eigen</em></a> is used to replace <em>Numpy</em> to generate random numbers.</p>
<h3 id="cutest-class-2">CUtest class</h3>
<pre><code class="language-cpp">// CUTest.hpp

#pragma once
#include &lt;Eigen/Dense&gt;
#include &lt;EigenRand/EigenRand&gt;
#include &lt;chrono&gt;
#include &lt;cmath&gt;
#include &lt;random&gt;
#include &lt;iostream&gt;

/// @brief standard deviation with 1 degree of freedom (unbiased)
/// @param array an Eigen array
/// @param ddof the degree of freedom, default is 1
/// @return the standard deviation of the array
double std_ddof(Eigen::ArrayXd array, int ddof);

class ChPTest {
public:
    // members
    Eigen::Array&lt;double, 10, 1&gt; s1;
    Eigen::Array&lt;double, 20, 1&gt; s2;
    Eigen::Array&lt;double, 30, 1&gt; stage_2;
    double k1{ 2.2 };
    double k2{ 0.5 };
    double k3{ 1.7 };
    double L{ 15 };
    double std_s1;
    double std_stage2;
    double mean_s1;
    double mean_stage2;

    Eigen::Array4d get_result();

    // constructor function
    ChPTest(const Eigen::ArrayXd&amp; s1_in, const Eigen::ArrayXd&amp; s2_in);
    ChPTest(const Eigen::ArrayXd&amp; s1_in, const Eigen::ArrayXd&amp; s2_in, const double k1_in, const double k2_in, const double k3_in, const double L_in);
    ~ChPTest();
};

class USPTest {
public:
    Eigen::Array&lt;double, 10, 1&gt; s1;
    Eigen::Array&lt;double, 20, 1&gt; s2;
    Eigen::Array&lt;double, 30, 1&gt; stage_2;
    double k1{ 2.4 };
    double k2{ 2.0 };
    double L1{ 15.0 };
    double L2{ 25.0 };
    double std_s1;
    double std_stage2;
    double mean_s1;
    double mean_stage2;

    // constructor function
    USPTest(const Eigen::ArrayXd&amp; s1_in, const Eigen::ArrayXd&amp; s2_in);
    USPTest(const Eigen::ArrayXd&amp; s1_in, const Eigen::ArrayXd&amp; s2_in, double k1_in, double k2_in, double L1_in, double L2_in);
    ~USPTest();
    // member function
    Eigen::Array4d get_result();
};

// CUTest.cpp
#include &quot;CUTest.hpp&quot;

// standard deviation with 1 degree of freedom (unbiased)
double std_ddof(Eigen::ArrayXd array, int ddof=1) {
    double standard_deviation = std::sqrt((array - array.mean()).square().sum() / (array.size() - ddof));
    return standard_deviation;
}

ChPTest::ChPTest(const Eigen::ArrayXd&amp; s1_in, const Eigen::ArrayXd&amp; s2_in) {
    // check length error
    if (s1_in.size() != 10) {
        throw(std::runtime_error(&quot;The length of s1 must be 10!&quot;));
    }
    if (s2_in.size() != 20) {
        throw(std::runtime_error(&quot;The length of s1 must be 10!&quot;));
    }
    s1 = s1_in;
    s2 = s2_in;
    stage_2 &lt;&lt; s1, s2;
    mean_s1 = s1.mean();
    std_s1 = std_ddof(s1, 1);
    mean_stage2 = stage_2.mean();
    std_stage2 = std_ddof(stage_2, 1);
}

ChPTest::ChPTest(const Eigen::ArrayXd&amp; s1_in, const Eigen::ArrayXd&amp; s2_in, const double k1_in, const double k2_in, const double k3_in, const double L_in) {
    // check length error
    if (s1_in.size() != 10) {
        throw(std::runtime_error(&quot;The length of s1 must be 10!&quot;));
    }
    if (s2_in.size() != 20) {
        throw(std::runtime_error(&quot;The legnth of s2 must be 20!&quot;));
    }

    s1 = s1_in;
    s2 = s2_in;
    k1 = k1_in;
    k2 = k2_in;
    k3 = k3_in;
    L = L_in;
    stage_2 &lt;&lt; s1, s2;
    mean_s1 = s1.mean();
    std_s1 = std_ddof(s1, 1);
    mean_stage2 = stage_2.mean();
    std_stage2 = std_ddof(stage_2, 1);
}

ChPTest::~ChPTest() { }

//defintion of member function get_result
Eigen::Array4d ChPTest::get_result() {
    int pass_s1 = 0;
    int pass_s2 = 0;
    int fail_s1 = 0;
    int fail_s2 = 0;

    double Ave = std::abs(100 - mean_s1);
    if (Ave + k1 * std_s1 &lt;= L) {
        pass_s1 = 1;
    }
    else if (Ave + std_s1 &gt; L) {
        fail_s1 = 1;
    }
    else {
        Ave = std::abs(100 - mean_stage2);
        if (Ave &lt;= k2 * L) {
            if (pow(Ave, 2) + pow(std_stage2, 2) &lt;= k2 * pow(L, 2)) {
                pass_s2 = 1;
            }
            else {
                fail_s2 = 1;
            }
        }
        else
        {
            if (Ave + k3 * std_stage2 &lt;= L) {
                pass_s2 = 1;
            }
            else {
                fail_s2 = 1;
            }
        }
    }
    Eigen::Array4d result;
    result &lt;&lt; pass_s1, pass_s2, fail_s1, fail_s2;
    return result;
}


USPTest::USPTest(const Eigen::ArrayXd&amp; s1_in, const Eigen::ArrayXd&amp; s2_in) {
    // check length error
    if (s1_in.size() != 10) {
        throw(&quot;The length of s1 must be 10!&quot;);
    }
    if (s2_in.size() != 20) {
        throw(&quot;The legnth of s2 must be 20!&quot;);
    }

    s1 = s1_in;
    s2 = s2_in;
    stage_2 &lt;&lt; s1, s2;
    mean_s1 = s1.mean();
    std_s1 = std_ddof(s1, 1);
    mean_stage2 = stage_2.mean();
    std_stage2 = std_ddof(stage_2, 1);
}

USPTest::USPTest(const Eigen::ArrayXd&amp; s1_in, const Eigen::ArrayXd&amp; s2_in, double k1_in, double k2_in, double L1_in, double L2_in)
{
    // check length error
    if (s1_in.size() != 10) {
        throw(&quot;The length of s1 must be 10!&quot;);
    }
    if (s2_in.size() != 20) {
        throw(&quot;The legnth of s2 must be 20!&quot;);
    }

    s1 = s1_in;
    s2 = s2_in;
    k1 = k1_in;
    k2 = k2_in;
    L1 = L1_in;
    L2 = L2_in;
    stage_2 &lt;&lt; s1, s2;
    mean_s1 = s1.mean();
    std_s1 = std_ddof(s1, 1);
    mean_stage2 = stage_2.mean();
    std_stage2 = std_ddof(stage_2, 1);
}

USPTest::~USPTest() {}

// return Eigen::Array4d [pass_s1, pass_s2, fail_s1, fail_s2]
Eigen::Array4d USPTest::get_result() {
    int pass_s1 = 0;
    int pass_s2 = 0;
    int fail_s1 = 0;  //no fail in stage 1, indeed
    int fail_s2 = 0;

    double Ave = 0;
    double Ave2 = 0;
    double limit = 0;
    if (mean_s1 &lt; 98.5) {
        Ave = 98.5 - mean_s1;
    }
    else if (mean_s1 &gt; 101.5) {
        Ave = mean_s1 - 101.5;
    }
    else {
        Ave = 0;
    }

    // stage 1 test
    if (Ave + k1 * std_s1 &lt;= L1) {
        pass_s1 = 1;
    }
    else {
        if (mean_stage2 &lt; 98.5) {
            Ave2 = 98.5 - mean_stage2;
            limit = 98.5;
        }
        else if (mean_stage2 &gt; 101.5) {
            Ave2 = mean_stage2 - 101.5;
            limit = 101.5;
        }
        else {
            Ave2 = 0;
            limit = mean_stage2;
        }

        if ((Ave2 + k2 * std_stage2 &lt;= L1) &amp;&amp; (stage_2 &gt;= (1 - 0.01 * L2) * limit).all() &amp;&amp; (stage_2 &lt;= (1 + 0.01 * L2) * limit).all()) {
            pass_s2 = 1;
        }
        else {
            fail_s2 = 1;
        }
    }
    Eigen::Array4d result;
    result &lt;&lt; pass_s1, pass_s2, fail_s1, fail_s2;
    return result;
}
</code></pre>
<h3 id="cusim-methods-2">CUsim methods</h3>
<p>Since the code is mainly for-loop, we can use <em>openmp</em> to speed it.</p>
<pre><code class="language-cpp">// CUSim.hpp

#pragma once
#include &quot;CUTest.hpp&quot;
/// @brief simulate CUtest under different standard deviation values and a fixed mean value
/// @param mu mean value of the normal distribution
/// @param start the start sd
/// @param end the end sd
/// @param mu_num the nunmber of sd values to be generated, defalt is 101
/// @param sim_num the simulation number, default is 10000
/// @param low_lvl the lower level of qualified tablets
/// @param upp_lvl the upper level of qualified tablets 
/// @param ck1 the value of k1 in ChPtest
/// @param ck2 the value of k2 in ChPtest
/// @param ck3 the value of k3 in ChPtest
/// @param cL the value of L in ChPtest
/// @param uk1 the value of k1 in USPtest
/// @param uk2 the value of k2 in USPtest
/// @param uL1 the value of L1 in USPtest
/// @param uL2 the value of L2 in USPtest
/// @return vector of [failrate, chp_acc_s1, chp_acc, usp_acc_s1, usp_acc, chp_pass_s1, chp_pass_s2, usp_pass_s1, usp_pass_s2, usp_fail_s1,  usp_fail_s2]
std::vector&lt;Eigen::ArrayXd&gt; sim_sd(double mu, double start, double end, int number_of_threads=8, int sd_num = 61, int sim_num = 10000, double low_lvl = 85.0, double upp_lvl = 115.0,
    double ck1 = 2.2, double ck2 = 0.25, double ck3 = 1.7, double cL = 15.0, double uk1 = 2.4, double uk2 = 2.0, double uL1 = 15.0, double uL2 = 25.0);

/// @brief simulate CUtest under different mean values and a fixed standard deviation
/// @param mu standard deviation of the normal distribution
/// @param start the start mu
/// @param end the end mu
/// @param mu_num the nunmber of mu values to be generated, defalt is 101
/// @param sim_num the simulation number, default is 10000
/// @param low_lvl the lower level of qualified tablets
/// @param upp_lvl the upper level of qualified tablets 
/// @param ck1 the value of k1 in ChPtest
/// @param ck2 the value of k2 in ChPtest
/// @param ck3 the value of k3 in ChPtest
/// @param cL the value of L in ChPtest
/// @param uk1 the value of k1 in USPtest
/// @param uk2 the value of k2 in USPtest
/// @param uL1 the value of L1 in USPtest
/// @param uL2 the value of L2 in USPtest
/// @return vector of [failrate, chp_acc_s1, chp_acc, usp_acc_s1, usp_acc, chp_pass_s1, chp_pass_s2, usp_pass_s1, usp_pass_s2, usp_fail_s1,  usp_fail_s2]
std::vector&lt;Eigen::ArrayXd&gt; sim_mu(double sd, double start, double end, int number_of_threads = 8, int mu_num=101, int sim_num=10000, double low_lvl=85.0, double upp_lvl=115.0,
    double ck1 = 2.2, double ck2 = 0.25, double ck3 = 1.7, double cL = 15.0, double uk1 = 2.4, double uk2 = 2.0, double uL1 = 15.0, double uL2 = 25.0);

// CUSim.cpp
#include &quot;CUTest.hpp&quot;
#include &lt;omp.h&gt;

std::vector&lt;Eigen::ArrayXd&gt; sim_sd(double mu, double start, double end, int number_of_threads, int sd_num, int sim_num, double low_lvl, double upp_lvl,
	double ck1, double ck2, double ck3, double cL, double uk1, double uk2, double uL1, double uL2) {
	int batch = 20000;    // simulate 20k tablets in one batch
	Eigen::ArrayXd failrate = Eigen::ArrayXd::Zero(sd_num);
	Eigen::ArrayXd chp_fail_s1 = Eigen::ArrayXd::Zero(sd_num);
	Eigen::ArrayXd chp_fail_s2 = Eigen::ArrayXd::Zero(sd_num);
	Eigen::ArrayXd chp_pass_s1 = Eigen::ArrayXd::Zero(sd_num);
	Eigen::ArrayXd chp_pass_s2 = Eigen::ArrayXd::Zero(sd_num);
	Eigen::ArrayXd usp_fail_s1 = Eigen::ArrayXd::Zero(sd_num);    // no fail in stage 1 test indeed
	Eigen::ArrayXd usp_fail_s2 = Eigen::ArrayXd::Zero(sd_num);
	Eigen::ArrayXd usp_pass_s1 = Eigen::ArrayXd::Zero(sd_num);
	Eigen::ArrayXd usp_pass_s2 = Eigen::ArrayXd::Zero(sd_num);
	Eigen::ArrayXd chp_acc_s1 = Eigen::ArrayXd::Zero(sd_num);
	Eigen::ArrayXd chp_acc = Eigen::ArrayXd::Zero(sd_num);
	Eigen::ArrayXd usp_acc_s1 = Eigen::ArrayXd::Zero(sd_num);
	Eigen::ArrayXd usp_acc = Eigen::ArrayXd::Zero(sd_num);

	std::random_device device;
#pragma omp parallel for num_threads(number_of_threads) collapse(2)
	for (int i = 0; i &lt; sd_num; i++) {
		double sd = start + (end - start) * i / double(sd_num - 1);

		// normal distribution
		
		Eigen::Rand::Vmt19937_64 urng{ device() };
		Eigen::Rand::NormalGen&lt;double&gt; norm_gen{mu, sd};
		Eigen::ArrayXd X = norm_gen.generate&lt;Eigen::ArrayXd&gt;(batch, 1, urng);

		failrate[i] = double((X &gt; upp_lvl || X &lt; low_lvl).count()) / batch;

		//result = np.array([pass_s1, pass_s2, fail_s1, fail_s2])
		Eigen::Array4d chp_result = Eigen::Array4d::Zero(4);
		Eigen::Array4d usp_result = Eigen::Array4d::Zero(4);

        Eigen::Rand::UniformIntGen&lt;int&gt; uni_int_gen{0, 19999};
        Eigen::Rand::Vmt19937_64 urng_uni_int{device()};
		std::mt19937 g(device());
		for (int j = 0; j &lt; sim_num; ++j) {
    		// a fast simulation method: generating 100 numbers between 0 and 19999
    		// then choose the unique elements from the 100 numbers
    		// use the first 10 unique numbers as the s1 indice
    		// use the 11th to 30th unique numbers as the s2 indice
            Eigen::ArrayXi rng_idx = uni_int_gen.generate&lt;Eigen::ArrayXi&gt;(100, 1, urng_uni_int);
            std::set&lt;int&gt; unique_idx{ rng_idx.begin(), rng_idx.end() };
            Eigen::ArrayXi unique_idx_30(30, 1);
            int count_elem = 0;
            for (int elem_unique : unique_idx) {
                unique_idx_30(count_elem) = elem_unique;
                count_elem += 1;
                if (count_elem == 30) {
                    break;
                }
            }
			Eigen::ArrayXd s1 = X(Eigen::seq(0, 9));
			Eigen::ArrayXd s2 = X(Eigen::seq(10, 29));
			ChPTest chp = ChPTest(s1, s2, ck1, ck2, ck3, cL);
			USPTest usp = USPTest(s1, s2, uk1, uk2, uL1, uL2);

			chp_result += chp.get_result();
			usp_result += usp.get_result();
		}

		chp_pass_s1[i] = chp_result[0] / double(sim_num);
		chp_pass_s2[i] = chp_result[1] / double(sim_num);
		chp_fail_s1[i] = chp_result[2] / double(sim_num);
		chp_fail_s2[i] = chp_result[3] / double(sim_num);
		usp_pass_s1[i] = usp_result[0] / double(sim_num);
		usp_pass_s2[i] = usp_result[1] / double(sim_num);
		usp_fail_s1[i] = usp_result[2] / double(sim_num);
		usp_fail_s2[i] = usp_result[3] / double(sim_num);

		if (failrate[i] &lt;= 0.05) {
			chp_acc_s1[i] = chp_pass_s1[i];
			chp_acc[i] = chp_pass_s1[i] + chp_pass_s2[i];
			usp_acc_s1[i] = usp_pass_s1[i];
			usp_acc[i] = usp_pass_s1[i] + usp_pass_s2[i];
		}
		else {
			chp_acc_s1[i] = chp_fail_s1[i];
			chp_acc[i] = chp_fail_s1[i] + chp_fail_s2[i];
			usp_acc[i] = usp_fail_s2[i];
		}
	}
	std::vector&lt;Eigen::ArrayXd&gt; result{ failrate, chp_acc_s1, chp_acc, usp_acc_s1, usp_acc, chp_pass_s1, chp_pass_s2, usp_pass_s1, usp_pass_s2, usp_fail_s1,  usp_fail_s2};
	return result;
}

std::vector&lt;Eigen::ArrayXd&gt; sim_mu(double sd, double start, double end, int number_of_threads, int mu_num, int sim_num, double low_lvl, double upp_lvl,
	double ck1, double ck2, double ck3, double cL, double uk1, double uk2, double uL1, double uL2) {
	int batch = 20000;    // simulate 20k tablets in one batch
	Eigen::ArrayXd failrate = Eigen::ArrayXd::Zero(mu_num);
	Eigen::ArrayXd chp_fail_s1 = Eigen::ArrayXd::Zero(mu_num);
	Eigen::ArrayXd chp_fail_s2 = Eigen::ArrayXd::Zero(mu_num);
	Eigen::ArrayXd chp_pass_s1 = Eigen::ArrayXd::Zero(mu_num);
	Eigen::ArrayXd chp_pass_s2 = Eigen::ArrayXd::Zero(mu_num);
	Eigen::ArrayXd usp_fail_s1 = Eigen::ArrayXd::Zero(mu_num);    // no fail in stage 1 test indeed
	Eigen::ArrayXd usp_fail_s2 = Eigen::ArrayXd::Zero(mu_num);
	Eigen::ArrayXd usp_pass_s1 = Eigen::ArrayXd::Zero(mu_num);
	Eigen::ArrayXd usp_pass_s2 = Eigen::ArrayXd::Zero(mu_num);
	Eigen::ArrayXd chp_acc_s1 = Eigen::ArrayXd::Zero(mu_num);
	Eigen::ArrayXd chp_acc = Eigen::ArrayXd::Zero(mu_num);
	Eigen::ArrayXd usp_acc_s1 = Eigen::ArrayXd::Zero(mu_num);
	Eigen::ArrayXd usp_acc = Eigen::ArrayXd::Zero(mu_num);
	std::random_device device;
#pragma omp parallel for num_threads(number_of_threads)  collapse(2)
	for (int i = 0; i &lt; mu_num; i++) {
		double mu = start + (end - start) * i / double(mu_num - 1);

		// normal distribution

		Eigen::Rand::Vmt19937_64 urng{ device() };
		Eigen::Rand::NormalGen&lt;double&gt; norm_gen{ mu, sd };
		Eigen::ArrayXd X = norm_gen.generate&lt;Eigen::ArrayXd&gt;(batch, 1, urng);

		failrate[i] = double((X &gt; upp_lvl || X &lt; low_lvl).count()) / batch;

		//result = np.array([pass_s1, pass_s2, fail_s1, fail_s2])
		Eigen::Array4d chp_result = Eigen::Array4d::Zero(4);
		Eigen::Array4d usp_result = Eigen::Array4d::Zero(4);

		// random draw 30 samples, first 10 as s1, last 20 as s2
		//Eigen::Rand::UniformIntGen&lt;int&gt; uni_int_gen{ 0, 19999 };
		//Eigen::Rand::Vmt19937_64 urng_uni_int{ device() };
		//Eigen::ArrayXi rng_idx = uni_int_gen.generate&lt;Eigen::ArrayXi&gt;(30, 1, urng_uni_int);
		std::mt19937 g(device());

		for (int j = 0; j &lt; sim_num; ++j) {
			//rng_idx = uni_int_gen.generate&lt;Eigen::ArrayXi&gt;(30, 1, urng_uni_int);
			//Eigen::ArrayXi idx_s1 = rng_idx(Eigen::seq(0, 9));
			//Eigen::ArrayXi idx_s2 = rng_idx(Eigen::seq(10, 29));
			//Eigen::Array&lt;double, 10, 1&gt; s1 = X(idx_s1);
			//Eigen::Array&lt;double, 20, 1&gt; s2 = X(idx_s2);

			std::shuffle(X.begin(), X.end(), g);
			Eigen::ArrayXd s1 = X(Eigen::seq(0, 9));
			Eigen::ArrayXd s2 = X(Eigen::seq(10, 29));
			ChPTest chp = ChPTest(s1, s2, ck1, ck2, ck3, cL);
			USPTest usp = USPTest(s1, s2, uk1, uk2, uL1, uL2);
			chp_result += chp.get_result();
			usp_result += usp.get_result();
		}

		chp_pass_s1[i] = chp_result[0] / double(sim_num);
		chp_pass_s2[i] = chp_result[1] / double(sim_num);
		chp_fail_s1[i] = chp_result[2] / double(sim_num);
		chp_fail_s2[i] = chp_result[3] / double(sim_num);
		usp_pass_s1[i] = usp_result[0] / double(sim_num);
		usp_pass_s2[i] = usp_result[1] / double(sim_num);
		usp_fail_s1[i] = usp_result[2] / double(sim_num);
		usp_fail_s2[i] = usp_result[3] / double(sim_num);

		if (failrate[i] &lt;= 0.05) {
			chp_acc_s1[i] = chp_pass_s1[i];
			chp_acc[i] = chp_pass_s1[i] + chp_pass_s2[i];
			usp_acc_s1[i] = usp_pass_s1[i];
			usp_acc[i] = usp_pass_s1[i] + usp_pass_s2[i];
		}
		else {
			chp_acc_s1[i] = chp_fail_s1[i];
			chp_acc[i] = chp_fail_s1[i] + chp_fail_s2[i];
			usp_acc[i] = usp_fail_s2[i];
		}
	}
	std::vector&lt;Eigen::ArrayXd&gt; result{ failrate, chp_acc_s1, chp_acc, usp_acc_s1, usp_acc, chp_pass_s1, chp_pass_s2, usp_pass_s1, usp_pass_s2, usp_fail_s1,  usp_fail_s2 };
	return result;
}
</code></pre>
<h3 id="binding">Binding</h3>
<p>We have used C++ to write the core part of the experiments and we now want to call the C++ code in Python. <em>Pybind11</em> provides many conversions between Python and C++, which helps to bind the two languages easily.</p>
<pre><code class="language-cpp">//bind.cpp
#include &lt;pybind11/pybind11.h&gt;
#include &lt;pybind11/eigen.h&gt;
#include &lt;pybind11/stl.h&gt;
#include &quot;CUSim.hpp&quot;
#include &quot;CUSim_fast.hpp&quot;

namespace py = pybind11;

PYBIND11_MODULE(cusim, m) {
    m.def(&quot;sim_sd&quot;, &amp;sim_sd, &quot;CUSim&quot;,
        py::arg(&quot;mu&quot;) = 100, py::arg(&quot;start&quot;) = 3, py::arg(&quot;end&quot;) = 15, py::arg(&quot;number_of_threads&quot;) = 8,
        py::arg(&quot;sd_num&quot;) = 61, py::arg(&quot;sim_num&quot;) = 10000, py::arg(&quot;low_lvl&quot;) = 85, py::arg(&quot;upp_lvl&quot;) = 115,
        py::arg(&quot;ck1&quot;) = 2.2, py::arg(&quot;ck2&quot;) = 0.25, py::arg(&quot;ck3&quot;) = 1.7, py::arg(&quot;cL&quot;) = 15,
        py::arg(&quot;uk1&quot;) = 2.4, py::arg(&quot;uk2&quot;) = 2.0, py::arg(&quot;uL1&quot;) = 15, py::arg(&quot;uL2&quot;) = 25);
    m.def(&quot;sim_mu&quot;, &amp;sim_mu, &quot;simulate mu&quot;,
        py::arg(&quot;sd&quot;) = 10, py::arg(&quot;start&quot;) = 90, py::arg(&quot;end&quot;) = 110, py::arg(&quot;number_of_threads&quot;) = 8,
        py::arg(&quot;mu_num&quot;) = 101, py::arg(&quot;sim_num&quot;) = 10000, py::arg(&quot;low_lvl&quot;) = 85, py::arg(&quot;upp_lvl&quot;) = 115,
        py::arg(&quot;ck1&quot;) = 2.2, py::arg(&quot;ck2&quot;) = 0.25, py::arg(&quot;ck3&quot;) = 1.7, py::arg(&quot;cL&quot;) = 15,
        py::arg(&quot;uk1&quot;) = 2.4, py::arg(&quot;uk2&quot;) = 2.0, py::arg(&quot;uL1&quot;) = 15, py::arg(&quot;uL2&quot;) = 25);
    m.def(&quot;sim_sd_fast&quot;, &amp;sim_sd_fast, &quot;simulate sd&quot;,
        py::arg(&quot;mu&quot;) = 100, py::arg(&quot;start&quot;) = 3, py::arg(&quot;end&quot;) = 15, py::arg(&quot;number_of_threads&quot;) = 8,
        py::arg(&quot;sd_num&quot;) = 61, py::arg(&quot;sim_num&quot;) = 10000, py::arg(&quot;low_lvl&quot;) = 85, py::arg(&quot;upp_lvl&quot;) = 115,
        py::arg(&quot;ck1&quot;) = 2.2, py::arg(&quot;ck2&quot;) = 0.25, py::arg(&quot;ck3&quot;) = 1.7, py::arg(&quot;cL&quot;) = 15,
        py::arg(&quot;uk1&quot;) = 2.4, py::arg(&quot;uk2&quot;) = 2.0, py::arg(&quot;uL1&quot;) = 15, py::arg(&quot;uL2&quot;) = 25);
    m.def(&quot;sim_mu_fast&quot;, &amp;sim_mu_fast, &quot;simulate mu&quot;,
        py::arg(&quot;sd&quot;) = 10, py::arg(&quot;start&quot;) = 90, py::arg(&quot;end&quot;) = 110, py::arg(&quot;number_of_threads&quot;) = 8,
        py::arg(&quot;mu_num&quot;) = 101, py::arg(&quot;sim_num&quot;) = 10000, py::arg(&quot;low_lvl&quot;) = 85, py::arg(&quot;upp_lvl&quot;) = 115,
        py::arg(&quot;ck1&quot;) = 2.2, py::arg(&quot;ck2&quot;) = 0.25, py::arg(&quot;ck3&quot;) = 1.7, py::arg(&quot;cL&quot;) = 15,
        py::arg(&quot;uk1&quot;) = 2.4, py::arg(&quot;uk2&quot;) = 2.0, py::arg(&quot;uL1&quot;) = 15, py::arg(&quot;uL2&quot;) = 25);
}
</code></pre>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Comparison Study of the Content Uniformity Tests in Chinese Pharmacopoeia and United States Pharmacopeia Based on Monte Carlo Simulation[J].Chin J Mod Appl Pharm, 2019, 36(19):2405-2410.DOI:10.13748/j.cnki.issn1007-7693.2019.19.008. <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

        </div>

        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://hxhc.xyz/tag/academic/">
            <span class="flex-auto">academic</span>
          </a>
        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://hxhc.xyz/tag/Software/">
            <span class="flex-auto">Software</span>
          </a>
        


        <div class="flex justify-between py-8">
          
            <div class="prev-post">
              <a href="https://hxhc.xyz/post/solving-the-problem-of-clangd-not-finding-system-header-of-msvc/">
                <h3 class="post-title">
                  <i class="ri-arrow-left-line"></i>
                  Solving the problem of clangd not finding system headers of MSVC
                </h3>
              </a>
            </div>
          

          
            <div class="next-post">
              <a href="https://hxhc.xyz/post/openblas-vs-intel-mkl-for-numpy/">
                <h3 class="post-title">
                  Openblas vs Intel MKL for Numpy and AMD CPUs
                  <i class="ri-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>

        
          
            <link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/gitalk/1.7.2/gitalk.css">
<script src="https://cdn.bootcdn.net/ajax/libs/gitalk/1.7.2/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: 'e8a467fa1547ec3d230a',
    clientSecret: '2a68cbc2236f231486004a9264438759e29d40f1',
    repo: 'hxhc.github.io',
    owner: 'hxhc',
    admin: ['hxhc'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

      </div>
    </div>


    <link rel="stylesheet" href="https://hxhc-blog.oss-cn-hangzhou.aliyuncs.com/media/prism-default-2.css">
    <script src="https://hxhc-blog.oss-cn-hangzhou.aliyuncs.com/media/prism-2.js"></script>

    <script>

    Prism.highlightAll()
    let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

    // This should probably be throttled.
    // Especially because it triggers during smooth scrolling.
    // https://lodash.com/docs/4.17.10#throttle
    // You could do like...
    // window.addEventListener("scroll", () => {
    //    _.throttle(doThatStuff, 100);
    // });
    // Only not doing it here to keep this Pen dependency-free.

    window.addEventListener("scroll", event => {
      let fromTop = window.scrollY;

      mainNavLinks.forEach((link, index) => {
        let section = document.getElementById(decodeURI(link.hash).substring(1));
        let nextSection = null
        if (mainNavLinks[index + 1]) {
          nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
        }
        if (section.offsetTop <= fromTop) {
          if (nextSection) {
            if (nextSection.offsetTop > fromTop) {
              link.classList.add("current");
            } else {
              link.classList.remove("current");
            }
          } else {
            link.classList.add("current");
          }
        } else {
          link.classList.remove("current");
        }
      });
    });


    document.addEventListener("DOMContentLoaded", function() {
      var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

      if ("IntersectionObserver" in window) {
        let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
          entries.forEach(function(entry) {
            if (entry.isIntersecting) {
              let lazyImage = entry.target
              lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
              lazyImage.classList.remove("lazy")
              lazyImageObserver.unobserve(lazyImage)
            }
          });
        });

        lazyImages.forEach(function(lazyImage) {
          lazyImageObserver.observe(lazyImage)
        })
      } else {
        // Possibly fall back to a more compatible method here
      }
    });

    const menuContainer = document.querySelector('.menu-container')
    const menus = document.querySelectorAll('.menu-container .menu')
    const mask = document.querySelector('.mask')
    const contentWrapper = document.querySelector('.content-wrapper')
    const latestArticle = document.querySelector('.latest-article')
    const readMore = document.querySelector('.read-more')
    const indexPage = document.querySelector('.index-page')

    const isHome = location.pathname === '/'
    if (latestArticle) {
      latestArticle.style.display = isHome ? 'block' : 'none'
      readMore.style.display = isHome ? 'block' : 'none'
      indexPage.style.display = isHome ? 'none' : 'block'
    }

    const openMenu = () => {
      menuContainer.classList.add('open')
      menus.forEach(menu => {
        menu.classList.add('animated', 'fadeInLeft')
      })
      mask.classList.add('open')
      contentWrapper.classList.add('is-second')
    }

    const closeMenu = () => {
      menuContainer.classList.remove('open')
      menus.forEach(menu => {
        menu.classList.remove('animated', 'fadeInLeft')
      })
      mask.classList.remove('open')
      contentWrapper.classList.remove('is-second')
    }

    </script>

    <script src="//instant.page/5.1.1" type="module" integrity="sha384-MWfCL6g1OTGsbSwfuMHc8+8J2u71/LA8dzlIN3ycajckxuZZmF+DNjdm7O6H3PSq"></script>




  </body>
</html>
